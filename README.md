# Dining Concierge Chatbot – Cloud Computing & Big Data (Fall 2025)

We built a full-stack, serverless web application as part of CS-GY 9223 (Cloud Computing & Big Data) at New York University. Our project implements a Dining Concierge Chatbot that recommends restaurants through natural conversation using AWS managed services.

## Overview

This system demonstrates an end-to-end serverless architecture using the following AWS services:

* **Amazon Lex:** Powers the conversational bot with `GreetingIntent`, `ThankYouIntent`, and `DiningSuggestionsIntent`.
* **Lambda Functions:**
    * **LF0:** Integrates with API Gateway to handle frontend chat requests.
    * **LF1:** Serves as a Lex code hook for slot validation and message formatting.
    * **LF2:** Acts as an SQS queue worker that fetches restaurant data and emails results via SES.
* **API Gateway:** Provides a REST API with an autogenerated JavaScript SDK for the frontend.
* **DynamoDB:** Stores detailed restaurant records sourced from the Yelp API.
* **OpenSearch Serverless:** Indexes restaurant IDs and cuisines for quick, randomized retrieval.
* **SQS + SES:** Manages asynchronous request handling and delivers automated email notifications.
* **CloudWatch Logs:** Monitors Lambda executions and traces messages sent to the Dead-Letter Queue (DLQ).

The frontend is a static site hosted in **S3** and interacts with the backend exclusively through the generated API Gateway SDK.



## Key Features

* **Fully Serverless:** Built entirely on a microservice-based, serverless design.
* **Rich Dataset:** Includes 1,000+ restaurants across 5 different cuisines collected via the Yelp API.
* **Secure & Accessible:** Features a CORS-enabled REST API and secured OpenSearch data access policies.
* **Automated Suggestions:** Delivers restaurant recommendations automatically with email notifications.
* **Resilient:** Integrated Dead-Letter Queue (DLQ) for handling failed SES email deliveries.

## Challenges and Fixes

### CORS Errors

Encountered and resolved Cross-Origin Resource Sharing (CORS) errors by including the necessary headers in the Lambda response object.

```json
"headers": {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type",
    "Access-Control-Allow-Methods": "OPTIONS,POST"
}
```
### OpenSearch Dashboard Unauthorized

* Fiex by updating the user's IAM tole policy:

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Action": [
      "aoss:CreateCollection", "aoss:ListCollections", "aoss:BatchGetCollection",
      "aoss:DeleteCollection", "aoss:CreateAccessPolicy", "aoss:ListAccessPolicies",
      "aoss:UpdateAccessPolicy", "aoss:CreateSecurityPolicy", "aoss:GetSecurityPolicy",
      "aoss:UpdateSecurityPolicy", "iam:ListUsers", "iam:ListRoles"
    ],
    "Effect": "Allow",
    "Resource": "*"
  }]
}
```

* Also ensured the correct IAM principal was listed in the OpenSearch data access policy.

## Event Bridge vs. SQS Trigger

* Initially, **EventBridge** was used to invoke LF2 on a schedule. However, this approach consumed events immediately and did not allow message-level retries or DLQ handling.
* To enable robust retry behavior and dead-letter queue support, **SQS** was configured as the Lambda trigger instead.
* This change ensured:
  * Automatic retries until maxReceiveCount is reached.
  * Failed messages move to the DLQ for later inspection.
  * Message ordering and delivery guarantees are preserved.

* EventBridge can use DLQs too, but its retry window is limited (24 hours) and does not provide the same queue-based reliability as SQS.

## Repository Structure 
```
├── front-end/            # S3-hosted static site (chat.html, assets)
├── lambda-functions/             # LF0, LF1, LF2 source code
├── other-scripts/       # Swagger spec, Yelp scraper, OpenSearch loader         
└── README.md
```

## Authors

* Sankirth Kalahasti (sk11617)
* Milind Kaushal (mk9694)

